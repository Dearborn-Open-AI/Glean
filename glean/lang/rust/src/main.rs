/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

// rust-glean/src/main.rs

//! A Glean indexer for Rust.
//!
//! Translates JSON files produced by `rustc -Z save-analysis` into Thrift that Glean can process.

#![warn(missing_docs)]

use crate::json_schema::Def;
use crate::json_schema::DefKind;
use crate::json_schema::Impl;
use crate::json_schema::ImplKind;
use crate::json_schema::Ref;
use crate::json_schema::RefId;
use crate::json_schema::Root;
use crate::json_schema::Span;
use clap::App;
use clap::Arg;
use eyre::eyre;
use eyre::WrapErr;
use fbthrift::serialize;
use fbthrift::simplejson_protocol::SimpleJsonProtocolSerializer;
use fbthrift::BufMutExt;
use fbthrift::ProtocolWriter;
use fbthrift::Serialize;
use fbthrift::SimpleJsonProtocol;
use fbthrift::TType;
use glean_schema_rust::types::ConstDef;
use glean_schema_rust::types::ConstDef_key;
use glean_schema_rust::types::Def as GleanDef;
use glean_schema_rust::types::DefLocation;
use glean_schema_rust::types::DefLocation_key;
use glean_schema_rust::types::EnumDef;
use glean_schema_rust::types::EnumDef_key;
use glean_schema_rust::types::FieldDef;
use glean_schema_rust::types::FieldDef_key;
use glean_schema_rust::types::FileXRefs;
use glean_schema_rust::types::FileXRefs_key;
use glean_schema_rust::types::ForeignFunctionDef;
use glean_schema_rust::types::ForeignFunctionDef_key;
use glean_schema_rust::types::ForeignStaticDef;
use glean_schema_rust::types::ForeignStaticDef_key;
use glean_schema_rust::types::FunctionDef;
use glean_schema_rust::types::FunctionDef_key;
use glean_schema_rust::types::Impl as GleanImpl;
use glean_schema_rust::types::ImplKind as GleanImplKind;
use glean_schema_rust::types::ImplLocation;
use glean_schema_rust::types::ImplLocation_key;
use glean_schema_rust::types::Impl_key;
use glean_schema_rust::types::LocalDef;
use glean_schema_rust::types::LocalDef_key;
use glean_schema_rust::types::MethodDef;
use glean_schema_rust::types::MethodDef_key;
use glean_schema_rust::types::ModuleDef;
use glean_schema_rust::types::ModuleDef_key;
use glean_schema_rust::types::Name;
use glean_schema_rust::types::QName;
use glean_schema_rust::types::QName_key;
use glean_schema_rust::types::StaticDef;
use glean_schema_rust::types::StaticDef_key;
use glean_schema_rust::types::StructDef;
use glean_schema_rust::types::StructDef_key;
use glean_schema_rust::types::StructVariantDef;
use glean_schema_rust::types::StructVariantDef_key;
use glean_schema_rust::types::TraitDef;
use glean_schema_rust::types::TraitDef_key;
use glean_schema_rust::types::TupleVariantDef;
use glean_schema_rust::types::TupleVariantDef_key;
use glean_schema_rust::types::Type;
use glean_schema_rust::types::TypeDef;
use glean_schema_rust::types::TypeDef_key;
use glean_schema_rust::types::Type_key;
use glean_schema_rust::types::UnionDef;
use glean_schema_rust::types::UnionDef_key;
use glean_schema_rust::types::XRef;
use glean_schema_rust::types::XRef_key;
use glean_schema_src::types::ByteSpan;
use glean_schema_src::types::File as SrcFile;
use glean_schema_src::types::FileLines;
use glean_schema_src::types::FileLines_key;
use std::collections::BTreeMap;
use std::fs::File;
use std::fs::{self};
use std::io::BufReader;
use std::io::Write;
use std::io::{self};
use std::mem;
use std::path::Path;
use std::process;

mod json_schema;

fn main() -> eyre::Result<()> {
    let matches = App::new("glean-rust")
        .version("0.1")
        .author("Patrick Walton <pcwalton@fb.com>")
        .about("Converts JSON generated by `rustc -Z save-analysis` to Thrift for use in Glean.")
        .arg(
            Arg::with_name("INPUT-JSON")
                .help("JSON file created with `rustc -Z save-analysis`")
                .multiple(true)
                .index(1)
                .required(true),
        )
        .arg(
            Arg::with_name("PATH-PREFIX")
                .help("Path fragment to prefix files with (e.g. 'fbcode')")
                .long("path-prefix")
                .takes_value(true)
                .required(false),
        )
        .get_matches();
    let input_paths = matches
        .values_of_os("INPUT-JSON")
        .ok_or(eyre!("while reading input-json arg"))?;
    let path_prefix = matches
        .value_of_os("PATH-PREFIX")
        .map(|s| s.to_str())
        .flatten();
    writeln!(io::stderr(), "Indexing {} files", input_paths.len())?;
    let mut glean_writer = GleanWriter::new();
    for input in input_paths.into_iter().map(Path::new) {
        let file = File::open(input).wrap_err("while reading input-json arg")?;
        let reader = BufReader::new(file);
        let root: Root = serde_json::from_reader(reader).wrap_err("failed to parse JSON")?;

        let (fullpath, path) = find_path(&root, path_prefix);
        let filelines = get_line_endings(&path);
        glean_writer.add_predicates_for_file(&root, &fullpath, filelines)?;
    }

    let output: &[u8] = &serialize!(SimpleJsonProtocol, |w| Serialize::write(
        &glean_writer.predicates,
        w
    ));
    io::stdout()
        .write_all(output)
        .wrap_err("while writing output")?;
    writeln!(io::stderr(), "Wrote {} bytes to stdout", output.len());
    Ok(())
}

// Find the source file associated with the analysis results.
// The special file "<input>" is used for non-attributable facts
fn find_path(root: &Root, prefix: Option<&str>) -> (String, String) {
    let rawpath = match root.defs.iter().find(|def| def.qualname == "::") {
        None => "<input>",
        Some(ref def) => &*def.value,
    };
    let path = match prefix {
        None => rawpath.to_string(),
        Some(anchor) => format!("{}/{}", anchor, rawpath),
    };
    (path, rawpath.to_string())
}

#[derive(Default)]
struct FileLinesFields {
    line_lengths: Vec<i64>,
    ends_in_newline: bool,
    has_unicode_or_tabs: bool,
}

// Process source file for byte offsets and encoding metadata
// We can be tolerant of failures here and return a default endings map
fn get_line_endings(path: &str) -> FileLinesFields {
    match path {
        "<input>" => return Default::default(),
        _ => match fs::read_to_string(path) {
            Err(_) => return Default::default(),
            Ok(contents) => return get_filelines_fields(contents),
        },
    }
}

fn get_filelines_fields(contents: String) -> FileLinesFields {
    // length in bytes of each line (using \n delimiters only)
    let lengths = contents
        .as_bytes()
        .split_inclusive(|c| *c == b'\n')
        .map(|l| l.len() as i64)
        .collect();

    // we need to know if multibyte encodings are possible
    let has_unicode_or_tabs = contents.contains(|c| c as u32 > 0x7F || c == '\t');
    let ends_in_newline = contents.ends_with('\n');

    FileLinesFields {
        line_lengths: lengths,
        ends_in_newline,
        has_unicode_or_tabs,
    }
}

type Id = i64;

struct GleanWriter {
    next_id: Id,
    predicates: Predicates,
    xrefs: BTreeMap<RefId, XRef>,
}

// NB: If you update this struct definition, you'll need to update
// `Predicates::write_json_for_defs` as well.
#[derive(Default)]
struct Predicates {
    files: Vec<SrcFile>,
    file_lines: Vec<FileLines>,
    const_defs: Vec<ConstDef>,
    enum_defs: Vec<EnumDef>,
    field_defs: Vec<FieldDef>,
    foreign_function_defs: Vec<ForeignFunctionDef>,
    foreign_static_defs: Vec<ForeignStaticDef>,
    function_defs: Vec<FunctionDef>,
    local_defs: Vec<LocalDef>,
    method_defs: Vec<MethodDef>,
    module_defs: Vec<ModuleDef>,
    static_defs: Vec<StaticDef>,
    struct_defs: Vec<StructDef>,
    struct_variant_defs: Vec<StructVariantDef>,
    trait_defs: Vec<TraitDef>,
    tuple_variant_defs: Vec<TupleVariantDef>,
    type_defs: Vec<TypeDef>,
    union_defs: Vec<UnionDef>,
    impls: Vec<GleanImpl>,
    def_locations: Vec<DefLocation>,
    impl_locations: Vec<ImplLocation>,
    xrefs: Vec<XRef>,
    file_xrefs: Vec<FileXRefs>,
}

impl Predicates {
    fn new() -> Predicates {
        Default::default()
    }

    fn write_def<B, P>(
        &self,
        serializer: &mut SimpleJsonProtocolSerializer<B>,
        predicate_thrift_name: &str,
        facts: &[P],
    ) where
        B: BufMutExt,
        P: Serialize<SimpleJsonProtocolSerializer<B>>,
    {
        serializer.write_list_value_begin();
        serializer.write_struct_begin("Predicate");
        serializer.write_field_begin("predicate", TType::String, 0);
        serializer.write_string(predicate_thrift_name);
        serializer.write_field_end();
        serializer.write_field_begin("facts", TType::List, 1);
        serializer.write_list_begin(TType::Struct, 0);
        for fact in facts {
            serializer.write_list_value_begin();
            Serialize::write(fact, serializer);
        }
        serializer.write_list_end();
        serializer.write_field_end();
        serializer.write_struct_end();
    }
}

impl<B> Serialize<SimpleJsonProtocolSerializer<B>> for Predicates
where
    B: BufMutExt,
{
    fn write(&self, serializer: &mut SimpleJsonProtocolSerializer<B>) {
        // NB: The Glean importer expects predicates to be topologically sortedâ€”that is, the
        // definition of an ID must come before any references to it. So it's important that
        // file predicates be emitted first.
        serializer.write_list_begin(TType::Struct, 0);
        self.write_def(serializer, "src.File.1", &self.files);
        self.write_def(serializer, "src.FileLines.1", &self.file_lines);
        self.write_def(serializer, "rust.ConstDef.1", &self.const_defs);
        self.write_def(serializer, "rust.EnumDef.1", &self.enum_defs);
        self.write_def(serializer, "rust.FieldDef.1", &self.field_defs);
        self.write_def(
            serializer,
            "rust.ForeignFunctionDef.1",
            &self.foreign_function_defs,
        );
        self.write_def(
            serializer,
            "rust.ForeignStaticDef.1",
            &self.foreign_static_defs,
        );
        self.write_def(serializer, "rust.FunctionDef.1", &self.function_defs);
        self.write_def(serializer, "rust.LocalDef.1", &self.local_defs);
        self.write_def(serializer, "rust.MethodDef.1", &self.method_defs);
        self.write_def(serializer, "rust.ModuleDef.1", &self.module_defs);
        self.write_def(serializer, "rust.StaticDef.1", &self.static_defs);
        self.write_def(serializer, "rust.StructDef.1", &self.struct_defs);
        self.write_def(
            serializer,
            "rust.StructVariantDef.1",
            &self.struct_variant_defs,
        );
        self.write_def(serializer, "rust.TraitDef.1", &self.trait_defs);
        self.write_def(
            serializer,
            "rust.TupleVariantDef.1",
            &self.tuple_variant_defs,
        );
        self.write_def(serializer, "rust.TypeDef.1", &self.type_defs);
        self.write_def(serializer, "rust.UnionDef.1", &self.union_defs);
        self.write_def(serializer, "rust.Impl.1", &self.impls);
        self.write_def(serializer, "rust.DefLocation.1", &self.def_locations);
        self.write_def(serializer, "rust.ImplLocation.1", &self.impl_locations);
        self.write_def(serializer, "rust.XRef.1", &self.xrefs);
        self.write_def(serializer, "rust.FileXRefs.1", &self.file_xrefs);
        serializer.write_list_end();
    }
}

impl GleanWriter {
    fn new() -> GleanWriter {
        GleanWriter {
            next_id: 1,
            predicates: Predicates::new(),
            xrefs: BTreeMap::new(),
        }
    }

    fn add_predicates_for_file(
        &mut self,
        root: &Root,
        path: &str,
        filelines: FileLinesFields,
    ) -> eyre::Result<()> {
        let file_id = self.add_predicate_for_file(path)?;
        self.add_predicate_for_filelines(file_id, filelines)?;
        for def in &root.defs {
            self.add_predicates_for_def(def, file_id)?;
        }
        for implementation in &root.impls {
            self.add_predicates_for_impl(implementation, file_id)?;
        }
        for reference in &root.refs {
            self.add_ref_to_xref(reference)?;
        }
        self.add_xref_predicates(&path);
        Ok(())
    }

    fn add_predicate_for_file(&mut self, path: &str) -> eyre::Result<i64> {
        let file_id = self.next_id();
        self.predicates.files.push(SrcFile {
            id: file_id,
            key: Some(path.to_owned()),
            ..Default::default()
        });
        Ok(file_id)
    }

    fn add_predicate_for_filelines(
        &mut self,
        file_id: i64,
        filelines: FileLinesFields,
    ) -> eyre::Result<i64> {
        let filelines_id = self.next_id();

        self.predicates.file_lines.push(FileLines {
            id: filelines_id,
            key: Some(Box::new(FileLines_key {
                file: SrcFile {
                    id: file_id,
                    key: None,
                    ..Default::default()
                },
                lengths: filelines.line_lengths,
                endsInNewline: filelines.ends_in_newline,
                hasUnicodeOrTabs: filelines.has_unicode_or_tabs,
                ..Default::default()
            })),
            ..Default::default()
        });
        Ok(filelines_id)
    }

    fn add_predicates_for_def(&mut self, def: &Def, file_id: i64) -> eyre::Result<()> {
        match def.kind {
            DefKind::Const => {
                self.add_predicates_for_const_def(def, file_id)?;
            }
            DefKind::Enum => {
                self.add_predicates_for_enum_def(def, file_id)?;
            }
            DefKind::Field => {
                self.add_predicates_for_field_def(def, file_id)?;
            }
            DefKind::ForeignFunction => {
                self.add_predicates_for_foreign_function_def(def, file_id)?;
            }
            DefKind::ForeignStatic => {
                self.add_predicates_for_foreign_static_def(def, file_id)?;
            }
            DefKind::Function => {
                self.add_predicates_for_function_def(def, file_id)?;
            }
            DefKind::Local => {
                self.add_predicates_for_local_def(def, file_id)?;
            }
            DefKind::Method => {
                self.add_predicates_for_method_def(def, file_id)?;
            }
            DefKind::Mod => {
                self.add_predicates_for_module_def(def, file_id)?;
            }
            DefKind::Static => {
                self.add_predicates_for_static_def(def, file_id)?;
            }
            DefKind::Struct => {
                self.add_predicates_for_struct_def(def, file_id)?;
            }
            DefKind::StructVariant => {
                self.add_predicates_for_struct_variant_def(def, file_id)?;
            }
            DefKind::Trait => {
                self.add_predicates_for_trait_def(def, file_id)?;
            }
            DefKind::TupleVariant => {
                self.add_predicates_for_tuple_variant_def(def, file_id)?;
            }
            DefKind::Type => {
                self.add_predicates_for_type_def(def, file_id)?;
            }
            DefKind::Union => {
                self.add_predicates_for_union_def(def, file_id)?;
            }
        };
        Ok(())
    }

    fn add_ref_to_xref(&mut self, reference: &Ref) -> eyre::Result<()> {
        if let Some(xref) = self.xrefs.get_mut(&reference.ref_id) {
            let byte_span = span_to_byte_span(&reference.span);
            xref.key
                .as_mut()
                .ok_or(eyre!("error while adding ref"))?
                .ranges
                .push(byte_span)
        }
        Ok(())
    }

    // As a side effect, this removes all XRefs.
    fn add_xref_predicates(&mut self, file_path: &str) {
        for xref in self.xrefs.values() {
            self.predicates.xrefs.push((*xref).clone());
        }
        let file_xrefs_id = self.next_id();
        let file_id = self.next_id();
        self.predicates.file_xrefs.push(FileXRefs {
            id: file_xrefs_id,
            key: Some(Box::new(FileXRefs_key {
                file: SrcFile {
                    id: file_id,
                    key: Some(file_path.to_owned()),
                    ..Default::default()
                },
                xrefs: mem::replace(&mut self.xrefs, BTreeMap::new())
                    .into_iter()
                    .map(|(_, xref)| xref)
                    .collect(),
                ..Default::default()
            })),
            ..Default::default()
        });
    }

    fn next_id(&mut self) -> Id {
        let id = self.next_id;
        self.next_id += 1;
        id
    }

    fn string_to_qname(&mut self, string: &str) -> eyre::Result<Option<QName>> {
        let mut parent = None;
        for piece in QualNameParser::new(string) {
            let child = QName {
                id: self.next_id(),
                key: Some(Box::new(QName_key {
                    local_name: self.string_to_name(piece?),
                    parent,
                    ..Default::default()
                })),
                ..Default::default()
            };
            parent = Some(child);
        }
        Ok(parent)
    }

    fn string_to_name(&mut self, string: &str) -> Name {
        Name {
            id: self.next_id(),
            key: Some(string.to_owned()),
            ..Default::default()
        }
    }

    fn string_to_type(&mut self, string: &str) -> Type {
        Type {
            id: self.next_id(),
            key: Some(Box::new(Type_key {
                repr: string.to_owned(),
                ..Default::default()
            })),
            ..Default::default()
        }
    }

    fn add_predicates_for_const_def(&mut self, def: &Def, file_id: i64) -> eyre::Result<()> {
        let def_predicate = ConstDef {
            id: self.next_id(),
            key: Some(Box::new(ConstDef_key {
                r#type: self.string_to_type(&def.value),
                name: self
                    .string_to_qname(&def.qualname)?
                    .ok_or(eyre!("Const didn't have a name!"))?,
                ..Default::default()
            })),
            ..Default::default()
        };
        let glean_def = GleanDef::const_(ConstDef {
            id: def_predicate.id,
            key: None,
            ..Default::default()
        });
        let def_location = self.predicate_for_def_location(&def, glean_def.clone(), file_id);
        let def_xref = self.predicate_for_def_xref(glean_def);
        self.predicates.const_defs.push(def_predicate);
        self.predicates.def_locations.push(def_location);
        self.predicates.xrefs.push(def_xref.clone());
        self.xrefs.insert(def.id.clone(), def_xref);
        Ok(())
    }

    fn add_predicates_for_enum_def(&mut self, def: &Def, file_id: i64) -> eyre::Result<()> {
        let def_predicate = EnumDef {
            id: self.next_id(),
            key: Some(Box::new(EnumDef_key {
                r#type: self.string_to_type(&def.value),
                name: self
                    .string_to_qname(&def.qualname)?
                    .ok_or(eyre!("Enum didn't have a name!"))?,
                ..Default::default()
            })),
            ..Default::default()
        };
        let glean_def = GleanDef::enum_(EnumDef {
            id: def_predicate.id,
            key: None,
            ..Default::default()
        });
        let def_location = self.predicate_for_def_location(&def, glean_def.clone(), file_id);
        let def_xref = self.predicate_for_def_xref(glean_def);
        self.predicates.enum_defs.push(def_predicate);
        self.predicates.def_locations.push(def_location);
        self.predicates.xrefs.push(def_xref.clone());
        self.xrefs.insert(def.id.clone(), def_xref);
        Ok(())
    }

    fn add_predicates_for_field_def(&mut self, def: &Def, file_id: i64) -> eyre::Result<()> {
        let def_predicate = FieldDef {
            id: self.next_id(),
            key: Some(Box::new(FieldDef_key {
                r#type: self.string_to_type(&def.value),
                name: self
                    .string_to_qname(&def.qualname)?
                    .ok_or(eyre!("Field didn't have a name!"))?,
                ..Default::default()
            })),
            ..Default::default()
        };
        let glean_def = GleanDef::field(FieldDef {
            id: def_predicate.id,
            key: None,
            ..Default::default()
        });
        let def_location = self.predicate_for_def_location(&def, glean_def.clone(), file_id);
        let def_xref = self.predicate_for_def_xref(glean_def);
        self.predicates.field_defs.push(def_predicate);
        self.predicates.def_locations.push(def_location);
        self.predicates.xrefs.push(def_xref.clone());
        self.xrefs.insert(def.id.clone(), def_xref);
        Ok(())
    }

    fn add_predicates_for_foreign_function_def(
        &mut self,
        def: &Def,
        file_id: i64,
    ) -> eyre::Result<()> {
        let def_predicate = ForeignFunctionDef {
            id: self.next_id(),
            key: Some(Box::new(ForeignFunctionDef_key {
                r#type: self.string_to_type(&def.value),
                name: self
                    .string_to_qname(&def.qualname)?
                    .ok_or(eyre!("Foreign function didn't have a name!"))?,
                ..Default::default()
            })),
            ..Default::default()
        };
        let glean_def = GleanDef::foreign_function(ForeignFunctionDef {
            id: def_predicate.id,
            key: None,
            ..Default::default()
        });
        let def_location = self.predicate_for_def_location(&def, glean_def.clone(), file_id);
        let def_xref = self.predicate_for_def_xref(glean_def);
        self.predicates.foreign_function_defs.push(def_predicate);
        self.predicates.def_locations.push(def_location);
        self.predicates.xrefs.push(def_xref.clone());
        self.xrefs.insert(def.id.clone(), def_xref);
        Ok(())
    }

    fn add_predicates_for_foreign_static_def(
        &mut self,
        def: &Def,
        file_id: i64,
    ) -> eyre::Result<()> {
        let def_predicate = ForeignStaticDef {
            id: self.next_id(),
            key: Some(Box::new(ForeignStaticDef_key {
                r#type: self.string_to_type(&def.value),
                name: self
                    .string_to_qname(&def.qualname)?
                    .ok_or(eyre!("Foreign static didn't have a name!"))?,
                ..Default::default()
            })),
            ..Default::default()
        };
        let glean_def = GleanDef::foreign_static(ForeignStaticDef {
            id: def_predicate.id,
            key: None,
            ..Default::default()
        });
        let def_location = self.predicate_for_def_location(&def, glean_def.clone(), file_id);
        let def_xref = self.predicate_for_def_xref(glean_def);
        self.predicates.foreign_static_defs.push(def_predicate);
        self.predicates.def_locations.push(def_location);
        self.predicates.xrefs.push(def_xref.clone());
        self.xrefs.insert(def.id.clone(), def_xref);
        Ok(())
    }

    fn add_predicates_for_function_def(&mut self, def: &Def, file_id: i64) -> eyre::Result<()> {
        let def_predicate = FunctionDef {
            id: self.next_id(),
            key: Some(Box::new(FunctionDef_key {
                r#type: self.string_to_type(&def.value),
                name: self
                    .string_to_qname(&def.qualname)?
                    .ok_or(eyre!("Function didn't have a name!"))?,
                ..Default::default()
            })),
            ..Default::default()
        };
        let glean_def = GleanDef::function_(FunctionDef {
            id: def_predicate.id,
            key: None,
            ..Default::default()
        });
        let def_location = self.predicate_for_def_location(&def, glean_def.clone(), file_id);
        let def_xref = self.predicate_for_def_xref(glean_def);
        self.predicates.function_defs.push(def_predicate);
        self.predicates.def_locations.push(def_location);
        self.predicates.xrefs.push(def_xref.clone());
        self.xrefs.insert(def.id.clone(), def_xref);
        Ok(())
    }

    fn add_predicates_for_local_def(&mut self, def: &Def, file_id: i64) -> eyre::Result<()> {
        let def_predicate = LocalDef {
            id: self.next_id(),
            key: Some(Box::new(LocalDef_key {
                r#type: self.string_to_type(&def.value),
                name: self
                    .string_to_qname(&def.qualname)?
                    .ok_or(eyre!("Local variable didn't have a name!"))?,
                ..Default::default()
            })),
            ..Default::default()
        };
        let glean_def = GleanDef::local(LocalDef {
            id: def_predicate.id,
            key: None,
            ..Default::default()
        });
        let def_location = self.predicate_for_def_location(&def, glean_def.clone(), file_id);
        let def_xref = self.predicate_for_def_xref(glean_def);
        self.predicates.local_defs.push(def_predicate);
        self.predicates.def_locations.push(def_location);
        self.predicates.xrefs.push(def_xref.clone());
        self.xrefs.insert(def.id.clone(), def_xref);
        Ok(())
    }

    fn add_predicates_for_method_def(&mut self, def: &Def, file_id: i64) -> eyre::Result<()> {
        let def_predicate = MethodDef {
            id: self.next_id(),
            key: Some(Box::new(MethodDef_key {
                r#type: self.string_to_type(&def.value),
                name: self
                    .string_to_qname(&def.qualname)?
                    .ok_or(eyre!("Method didn't have a name!"))?,
                ..Default::default()
            })),
            ..Default::default()
        };
        let glean_def = GleanDef::method(MethodDef {
            id: def_predicate.id,
            key: None,
            ..Default::default()
        });
        let def_location = self.predicate_for_def_location(&def, glean_def.clone(), file_id);
        let def_xref = self.predicate_for_def_xref(glean_def);
        self.predicates.method_defs.push(def_predicate);
        self.predicates.def_locations.push(def_location);
        self.predicates.xrefs.push(def_xref.clone());
        self.xrefs.insert(def.id.clone(), def_xref);
        Ok(())
    }

    fn add_predicates_for_module_def(&mut self, def: &Def, file_id: i64) -> eyre::Result<()> {
        let name = match self.string_to_qname(&def.qualname)? {
            Some(name) => name,
            None => {
                // This can happen for the top-level module. Just discard it.
                return Ok(());
            }
        };

        let def_predicate = ModuleDef {
            id: self.next_id(),
            key: Some(Box::new(ModuleDef_key {
                name,
                ..Default::default()
            })),
            ..Default::default()
        };
        let glean_def = GleanDef::module(ModuleDef {
            id: def_predicate.id,
            key: None,
            ..Default::default()
        });
        let def_location = self.predicate_for_def_location(&def, glean_def.clone(), file_id);
        let def_xref = self.predicate_for_def_xref(glean_def);
        self.predicates.module_defs.push(def_predicate);
        self.predicates.def_locations.push(def_location);
        self.predicates.xrefs.push(def_xref.clone());
        self.xrefs.insert(def.id.clone(), def_xref);
        Ok(())
    }

    fn add_predicates_for_static_def(&mut self, def: &Def, file_id: i64) -> eyre::Result<()> {
        let def_predicate = StaticDef {
            id: self.next_id(),
            key: Some(Box::new(StaticDef_key {
                r#type: self.string_to_type(&def.value),
                name: self
                    .string_to_qname(&def.qualname)?
                    .ok_or(eyre!("Static didn't have a name!"))?,
                ..Default::default()
            })),
            ..Default::default()
        };
        let glean_def = GleanDef::static_(StaticDef {
            id: def_predicate.id,
            key: None,
            ..Default::default()
        });
        let def_location = self.predicate_for_def_location(&def, glean_def.clone(), file_id);
        let def_xref = self.predicate_for_def_xref(glean_def);
        self.predicates.static_defs.push(def_predicate);
        self.predicates.def_locations.push(def_location);
        self.predicates.xrefs.push(def_xref.clone());
        self.xrefs.insert(def.id.clone(), def_xref);
        Ok(())
    }

    fn add_predicates_for_struct_def(&mut self, def: &Def, file_id: i64) -> eyre::Result<()> {
        let def_predicate = StructDef {
            id: self.next_id(),
            key: Some(Box::new(StructDef_key {
                name: self
                    .string_to_qname(&def.qualname)?
                    .ok_or(eyre!("Struct didn't have a name!"))?,
                ..Default::default()
            })),
            ..Default::default()
        };
        let glean_def = GleanDef::struct_(StructDef {
            id: def_predicate.id,
            key: None,
            ..Default::default()
        });
        let def_location = self.predicate_for_def_location(&def, glean_def.clone(), file_id);
        let def_xref = self.predicate_for_def_xref(glean_def);
        self.predicates.struct_defs.push(def_predicate);
        self.predicates.def_locations.push(def_location);
        self.predicates.xrefs.push(def_xref.clone());
        self.xrefs.insert(def.id.clone(), def_xref);
        Ok(())
    }

    fn add_predicates_for_struct_variant_def(
        &mut self,
        def: &Def,
        file_id: i64,
    ) -> eyre::Result<()> {
        let def_predicate = StructVariantDef {
            id: self.next_id(),
            key: Some(Box::new(StructVariantDef_key {
                name: self
                    .string_to_qname(&def.qualname)?
                    .ok_or(eyre!("Struct-like enum variant didn't have a name!"))?,
                ..Default::default()
            })),
            ..Default::default()
        };
        let glean_def = GleanDef::struct_variant(StructVariantDef {
            id: def_predicate.id,
            key: None,
            ..Default::default()
        });
        let def_location = self.predicate_for_def_location(&def, glean_def.clone(), file_id);
        let def_xref = self.predicate_for_def_xref(glean_def);
        self.predicates.struct_variant_defs.push(def_predicate);
        self.predicates.def_locations.push(def_location);
        self.predicates.xrefs.push(def_xref.clone());
        self.xrefs.insert(def.id.clone(), def_xref);
        Ok(())
    }

    fn add_predicates_for_trait_def(&mut self, def: &Def, file_id: i64) -> eyre::Result<()> {
        let def_predicate = TraitDef {
            id: self.next_id(),
            key: Some(Box::new(TraitDef_key {
                name: self
                    .string_to_qname(&def.qualname)?
                    .ok_or(eyre!("Trait didn't have a name!"))?,
                ..Default::default()
            })),
            ..Default::default()
        };
        let glean_def = GleanDef::r#trait(TraitDef {
            id: def_predicate.id,
            key: None,
            ..Default::default()
        });
        let def_location = self.predicate_for_def_location(&def, glean_def.clone(), file_id);
        let def_xref = self.predicate_for_def_xref(glean_def);
        self.predicates.trait_defs.push(def_predicate);
        self.predicates.def_locations.push(def_location);
        self.predicates.xrefs.push(def_xref.clone());
        self.xrefs.insert(def.id.clone(), def_xref);
        Ok(())
    }

    fn add_predicates_for_tuple_variant_def(
        &mut self,
        def: &Def,
        file_id: i64,
    ) -> eyre::Result<()> {
        let def_predicate = TupleVariantDef {
            id: self.next_id(),
            key: Some(Box::new(TupleVariantDef_key {
                name: self
                    .string_to_qname(&def.qualname)?
                    .ok_or(eyre!("Tuple-like enum variant didn't have a name!"))?,
                ..Default::default()
            })),
            ..Default::default()
        };
        let glean_def = GleanDef::tuple_variant(TupleVariantDef {
            id: def_predicate.id,
            key: None,
            ..Default::default()
        });
        let def_location = self.predicate_for_def_location(&def, glean_def.clone(), file_id);
        let def_xref = self.predicate_for_def_xref(glean_def);
        self.predicates.tuple_variant_defs.push(def_predicate);
        self.predicates.def_locations.push(def_location);
        self.predicates.xrefs.push(def_xref.clone());
        self.xrefs.insert(def.id.clone(), def_xref);
        Ok(())
    }

    fn add_predicates_for_type_def(&mut self, def: &Def, file_id: i64) -> eyre::Result<()> {
        let def_predicate = TypeDef {
            id: self.next_id(),
            key: Some(Box::new(TypeDef_key {
                r#type: self.string_to_type(&def.value),
                name: self
                    .string_to_qname(&def.qualname)?
                    .ok_or(eyre!("Type definition didn't have a name!"))?,
                ..Default::default()
            })),
            ..Default::default()
        };
        let glean_def = GleanDef::r#type(TypeDef {
            id: def_predicate.id,
            key: None,
            ..Default::default()
        });
        let def_location = self.predicate_for_def_location(def, glean_def.clone(), file_id);
        let def_xref = self.predicate_for_def_xref(glean_def);
        self.predicates.type_defs.push(def_predicate);
        self.predicates.def_locations.push(def_location);
        self.predicates.xrefs.push(def_xref.clone());
        self.xrefs.insert(def.id.clone(), def_xref);
        Ok(())
    }

    fn add_predicates_for_union_def(&mut self, def: &Def, file_id: i64) -> eyre::Result<()> {
        let def_predicate = UnionDef {
            id: self.next_id(),
            key: Some(Box::new(UnionDef_key {
                name: self
                    .string_to_qname(&def.qualname)?
                    .ok_or(eyre!("Union definition didn't have a name!"))?,
                ..Default::default()
            })),
            ..Default::default()
        };
        let glean_def = GleanDef::union_(UnionDef {
            id: def_predicate.id,
            key: None,
            ..Default::default()
        });
        let def_location = self.predicate_for_def_location(def, glean_def.clone(), file_id);
        let def_xref = self.predicate_for_def_xref(glean_def);
        self.predicates.union_defs.push(def_predicate);
        self.predicates.def_locations.push(def_location);
        self.predicates.xrefs.push(def_xref.clone());
        self.xrefs.insert(def.id.clone(), def_xref);
        Ok(())
    }

    fn add_predicates_for_impl(&mut self, implementation: &Impl, file_id: i64) -> eyre::Result<()> {
        let impl_predicate = GleanImpl {
            id: self.next_id(),
            key: Some(Box::new(Impl_key {
                kind: match implementation.kind {
                    ImplKind::Direct => GleanImplKind::direct,
                    ImplKind::Inherent => GleanImplKind::inherent,
                },
                ..Default::default()
            })),
            ..Default::default()
        };
        let glean_impl = GleanImpl {
            id: impl_predicate.id,
            key: None,
            ..Default::default()
        };
        let impl_location = self.predicate_for_impl_location(implementation, glean_impl, file_id);
        self.predicates.impls.push(impl_predicate);
        self.predicates.impl_locations.push(impl_location);
        Ok(())
    }

    fn predicate_for_def_location(
        &mut self,
        def: &Def,
        glean_def: GleanDef,
        file_id: i64,
    ) -> DefLocation {
        DefLocation {
            id: self.next_id(),
            key: Some(Box::new(DefLocation_key {
                def_: glean_def,
                file: SrcFile {
                    id: file_id,
                    key: None,
                    ..Default::default()
                },
                span: span_to_byte_span(&def.span),
                ..Default::default()
            })),
            ..Default::default()
        }
    }

    fn predicate_for_def_xref(&mut self, glean_def: GleanDef) -> XRef {
        XRef {
            id: self.next_id(),
            key: Some(Box::new(XRef_key {
                target: glean_def,
                ranges: vec![],
                ..Default::default()
            })),
            ..Default::default()
        }
    }

    fn predicate_for_impl_location(
        &mut self,
        implementation: &Impl,
        glean_impl: GleanImpl,
        file_id: i64,
    ) -> ImplLocation {
        ImplLocation {
            id: self.next_id(),
            key: Some(Box::new(ImplLocation_key {
                r#impl: glean_impl,
                file: SrcFile {
                    id: file_id,
                    key: None,
                    ..Default::default()
                },
                span: span_to_byte_span(&implementation.span),
                ..Default::default()
            })),
            ..Default::default()
        }
    }
}

fn span_to_byte_span(span: &Span) -> ByteSpan {
    ByteSpan {
        start: span.byte_start as i64,
        length: span.byte_end as i64 - span.byte_start as i64,
        ..Default::default()
    }
}

struct QualNameParser<'a> {
    input: &'a str,
}

impl<'a> QualNameParser<'a> {
    fn new(mut input: &'a str) -> QualNameParser<'a> {
        if input.starts_with("::") {
            input = &input[2..];
        }
        if input.starts_with('<') {
            input = &input[1..];
        }
        QualNameParser { input }
    }
}

impl<'a> Iterator for QualNameParser<'a> {
    type Item = eyre::Result<&'a str>;

    fn next(&mut self) -> Option<eyre::Result<&'a str>> {
        if self.input.is_empty() {
            return None;
        }

        // Parse next piece.
        let end_index = self
            .input
            .find(|ch: char| !ch.is_alphanumeric() && ch != '_')
            .unwrap_or_else(|| self.input.len());
        let result = &self.input[0..end_index];
        self.input = &self.input[end_index..];

        // Skip ignorable.
        let next_start_index;
        if self.input.starts_with(" as ") {
            next_start_index = match self
                .input
                .find(">::")
                .ok_or_else(|| eyre!("could not find >::"))
                .wrap_err_with(|| eyre!("while parsing {}", self.input))
                .wrap_err("Found `as` with no `>`")
            {
                Ok(index) => index + 3,
                Err(err) => return Some(Err(err)),
            }
        } else if self.input.starts_with('$') {
            next_start_index = self.input.len();
        } else {
            next_start_index = self
                .input
                .find(|ch: char| ch.is_alphanumeric() || ch == '_')
                .unwrap_or_else(|| self.input.len());
        }
        self.input = &self.input[next_start_index..];
        Some(Ok(result))
    }
}

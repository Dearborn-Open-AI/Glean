# Copyright (c) Facebook, Inc. and its affiliates.

# common predicates between java and kotlin used for interopobility
schema kotlin.alpha.2 {
  import javakotlin.alpha.1
  import src.1

# table of definitions of things
predicate DeclarationLocation : {
    file : src.File,
    span : src.ByteSpan
}

predicate Type :
  {
    type : javakotlin.alpha.Type,
    location : maybe DeclarationLocation,
    typeArgs: [TypeArg],
    isNullable: bool
  }

predicate TypeArg: {
  type: Type
}

  # A variable declaration
predicate VariableDeclaration :
  {
    name: javakotlin.alpha.QName,
    type : Type,
    location : DeclarationLocation,
  }

# A method declaration
predicate MethodDeclaration :
  {
    name : javakotlin.alpha.MethodName,
    parameters : [VariableDeclaration],
    returnType : maybe Type,
    loc : src.Loc, # this needs to be a src.ByteSpan
    container: maybe Declaration
  }

predicate ClassDeclaration :
  {
    name : javakotlin.alpha.QName,
    implements_ : [javakotlin.alpha.QName],
    location : DeclarationLocation,
  }

# The type of Kotlin symbol entities
type Declaration =
  {
    class_ : ClassDeclaration |
    method : MethodDeclaration |
    variable : VariableDeclaration |
  }

#
# Re-indexing by file for codemarkup use
#

predicate FileDeclarations:
  {
    file: src.File,
    decl: Declaration
  } stored { File, Decl } where
    ( ( CDecl = ClassDeclaration { location = Loc };
        { class_ = CDecl }  = Decl;
      ) | (
        VDecl = VariableDeclaration { location = Loc };
        { variable = VDecl } = Decl;
      );
      { file = File } = Loc;
    ) | (
      MDecl = MethodDeclaration { loc = { file = File } };
      { method = MDecl } = Decl;
    )

predicate DeclarationFileLocation:
  {
    decl: Declaration,
    file: src.File,
    span: src.ByteSpan,
    name: string,
  }
  { Decl, File, Span, NameStr } where
    ( ( { class_ = CDecl }  = Decl;
        ClassDeclaration { location = Location, name = QName } = CDecl;
      ) | (
        { variable = VDecl } = Decl;
        VariableDeclaration { location = Location, name = QName } = VDecl;
      );
      { File, Span } = Location;
      { name = javakotlin.alpha.Name NameStr } = QName;
    ) | (
      { method = MDecl } = Decl;
      MethodDeclaration { name = MName, loc = SrcLoc} = MDecl;
      javakotlin.alpha.MethodName { name = QName } = MName;
      { name = javakotlin.alpha.Name NameStr } = QName;
      { file = File } = SrcLoc;
      { 0, 1 } = Span; # fake span todo
    )

# entity relationships

# Container parent (by scope)
predicate ParentDeclaration:
  {
    child: Declaration,
    parent: Declaration
  }
  { Child, Parent } where
    { method = MDecl } = Child;
    { container = { just = Parent } } = MDecl

# extends parent (classes `implement` interfaces, but we don't have
# InterfaceDecls currently). So this isn't very useful yet
predicate ExtendsDeclaration:
  {
    child: Declaration,
    parent: Declaration
  }
  { Child, Parent } where
    { class_ = CDecl } = Child;
    { implements_ = QNames } = CDecl;
    QName = QNames[..];
    PDecl = ClassDeclaration { name = QName }; # don't think this matches
    { class_ = PDecl } = Parent

}

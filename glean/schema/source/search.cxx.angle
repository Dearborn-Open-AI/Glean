# Copyright (c) Facebook, Inc. and its affiliates.

schema search.cxx.5 {
import cxx1.5
import code.cxx.4

# Declarations with no scope
predicate GlobalDeclarationWithName :
  {
    name : cxx1.Name,
    decl : cxx1.Declaration,
  }
  { N, D }
  where
  D =
    (
      cxx1.Declaration
        {
          objcContainer =
            {
              id =
                { protocol = N } |
                { interface_ = N } |
                { categoryInterface = { className = N } } |
                { extensionInterface = N } |
                { implementation = N } |
                { categoryImplementation = { className = N } }
            }
        }
    ) |
    (cxx1.Declaration { objcProperty = { name = N }})

predicate DeclIsDefn : { decl : cxx1.Declaration, defn : code.cxx.Definition }
  { Decl, Defn }
  where
  Defn =
    (code.cxx.Definition { record_ = { declaration = D } }
      where { record_ = D } = Decl ) |
    (code.cxx.Definition { function_ = { declaration = D } }
      where { function_ = D } = Decl ) |
    (code.cxx.Definition { enum_ = { declaration = D } }
      where { enum_ = D } = Decl )  |
    (code.cxx.Definition { objcMethod = cxx1.ObjcMethodDefinition D }
      where { objcMethod = D } = Decl ) |
    (code.cxx.Definition { objcContainer = { declaration = D } }
      where { objcContainer = D } = Decl ) |
    (code.cxx.Definition { variable = D }
      where { variable = D } = Decl;
            D = cxx1.VariableDeclaration
                  { kind = { global_ = { definition = true }}} )

predicate SearchByNameAndScope :
  {
    name : cxx1.Name,
    scope : cxx1.Scope,
    entity : code.cxx.Entity,
  }
  {N, Scope, Entity} where
    (
      # Several things use QName, so share the query for it
      Q = cxx1.QName { name = N, scope = Scope };
      Entity =
        code.cxx.Entity { decl = { record_ = { name = Q }}}  |
        code.cxx.Entity { decl = { variable = { name = Q }}} |
        code.cxx.Entity { decl = { typeAlias = { name = Q }}} |
        code.cxx.Entity { decl = { enum_ = { name = Q }}};
    ) | (
      D = cxx1.FunctionDeclaration
        { name = { name = { name = N }, scope = Scope } };
      Entity = code.cxx.Entity { decl = { function_ = D } }
    ) | (
      GlobalDeclarationWithName { N, Decl };
      Entity = code.cxx.Entity { decl = Decl };
      { global_ = {} } = Scope;
    ) | (
      E = cxx1.Enumerator { name = N, enumeration = T };
      { name = QN, isScoped = Scoped } = T;
      (
        false = Scoped;
        { scope = Scope } = QN
      ) | (
        true = Scoped;
        { recordWithAccess = { record = QN, access = Public }} = Scope
      );
      Entity = code.cxx.Entity { enumerator = E };
    )

predicate SearchByScope :
  {
    scope : cxx1.Scope,
    entity : code.cxx.Entity,
  }
  {Scope, Entity} where
    (
        {namespace_= QName } = Scope;
        NS = cxx1.NamespaceDeclaration { name = QName };
        Entity = code.cxx.Entity { decl = { namespace_ = NS } };
    )

predicate SearchBySelector :
  {
    selector : cxx1.ObjcSelector,
    entity : code.cxx.Entity,
  }
  { Selector, Ent } where
  Ent = code.cxx.Entity { decl = { objcMethod = { selector = Selector }}}

# Easy way to query for TargetUses for an Entity. Note this doesn't
# handle the `defn` alternative of `code.cxx.Entity`, but the
# call site of this predicate ('Glean.Search.Search') always uses it
# with declarations and not definitions.
predicate EntityUses :
  {
    entity : code.cxx.Entity,
    uses : cxx1.TargetUses
  }
  { E, U } where
    (
      code.cxx.Entity { decl = D } = E;
      U = cxx1.TargetUses { target = { declaration = D } }
    ) | (
      code.cxx.Entity { enumerator = En } = E;
      U = cxx1.TargetUses { target = { enumerator = En } }
    )

#
# Generating scope values for queries
#

# Compile search query tuples into scope facts
predicate QueryToScope :
  {
    query : [string],
    scope : cxx1.Scope
  }
  { Query, Scope } where
    # global wild
    ( [] = Query;
      { global_ = _ } ) |
    # namespace scope
    ( QueryToNSQName { Query, NSQName };
      { namespace_ = NSQName } ) = Scope;
    # todo: records

# compile to namespace qname
predicate QueryToNSQName:
  {
    query : [string],
    scope : cxx1.NamespaceQName
  }
  { Query, NSQName } where
    # zero tuple
    ( [] = Query;
      { nothing, nothing } ) |
    # one tuple
    ( [A] = Query;
      { name = { just = cxx1.Name A }} ) | # parent wild

    # should I not be able to write?
    # recursive reference to predicate
    # search.cxx.QueryToNSQName.5 .. in
    # ( [B,A] = Query;
    #   { just = cxx1.Name A } = AName;
    #   QueryToNSQName { [B], Parent };
    #   { name = AName, parent = { just = Parent } } ) |

    # two tuple (can we write this recursively? ...)
    ( [B,A] = Query;
      { just = cxx1.Name A } = AName;
      { just = { name = { just = cxx1.Name B } } } = BName;
      { name = AName, parent = BName } ) |
    # three tuple
    ( [C,B,A] = Query;
      { just = cxx1.Name A } = AName;
      { just = cxx1.Name B } = BName;
      { just = cxx1.Name C } = CName;
      { name = AName, parent = { just = { name = BName,
        parent = { just = { name = CName }}}}} ) |
    # four tuple
    ( [D,C,B,A] = Query;
      { just = cxx1.Name A } = AName;
      { just = cxx1.Name B } = BName;
      { just = cxx1.Name C } = CName;
      { just = cxx1.Name D } = DName;
      { name = AName, parent = { just = { name = BName,
        parent = { just = { name = CName,
          parent = { just = { name = DName }}}}}}} ) |
    # five tuple
    ( [E,D,C,B,A] = Query;
      { just = cxx1.Name A } = AName;
      { just = cxx1.Name B } = BName;
      { just = cxx1.Name C } = CName;
      { just = cxx1.Name D } = DName;
      { just = cxx1.Name E } = EName;
      { name = AName, parent = { just = { name = BName,
        parent = { just = { name = CName,
          parent = { just = { name = DName,
            parent = { just = { name = EName }}}}}}}}} ) |
    # six tuple
     ( [F,E,D,C,B,A] = Query;
       { just = cxx1.Name A } = AName;
       { just = cxx1.Name B } = BName;
       { just = cxx1.Name C } = CName;
       { just = cxx1.Name D } = DName;
       { just = cxx1.Name E } = EName;
       { just = cxx1.Name F } = FName;
       { name = AName, parent = { just = { name = BName,
         parent = { just = { name = CName,
           parent = { just = { name = DName,
             parent = { just = { name = EName,
               parent = { just = { name = FName } } }}}}}}}}} ) |
    # seven for real
     ( [G,F,E,D,C,B,A] = Query;
       { just = cxx1.Name A } = AName;
       { just = cxx1.Name B } = BName;
       { just = cxx1.Name C } = CName;
       { just = cxx1.Name D } = DName;
       { just = cxx1.Name E } = EName;
       { just = cxx1.Name F } = FName;
       { just = cxx1.Name G } = GName;
       { name = AName, parent = { just = { name = BName,
         parent = { just = { name = CName,
           parent = { just = { name = DName,
             parent = { just = { name = EName,
               parent = { just = { name = FName,
                 parent = { just = { name = GName }}}}}}}}}}}}}

    ) = NSQName;

}

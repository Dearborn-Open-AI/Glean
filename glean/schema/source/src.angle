# Copyright (c) Facebook, Inc. and its affiliates.

schema src.1 {

# Path to the source file relative to the repository root
predicate File : string

#Â Source code digests produced by unspecified hash function
predicate FileDigest : File -> string

# Common source code location type
type Loc = {
  file : File,
  line : nat,
  column : nat,
   # Each Unicode code point occupies one column, even if it spans multiple
   # bytes. Combining characters are not taken into account.
   # A tab character occupies a single column.
}

# Common source code range type
# Expect: 1-based line and column numbers, Begin and End are inclusive.
type Range = {
  file : File,
  lineBegin : nat,
  columnBegin : nat,
  lineEnd : nat,
  columnEnd : nat,
}

# DEPRECATED
type ByteRange = {
  begin : nat,
  end : nat,
}

predicate FileLines : {
  file : File,
  lengths : [nat],
    # length of each line, including the terminating newline (if any)
    # NOTE: we store length rather than offset because it is shorter;
    # offsets can be recovered via scanl' (+) 0
  endsInNewline : bool,
    # does the last line end in a newline?
  hasUnicodeOrTabs : bool,
    # does the file have any multibyte UTF-8 code points or tabs
}

# A span of bytes within a file
# NB. Byte spans don't assume any conversion of the source code, so CRLF counts
# as two bytes
type ByteSpan = {
  start : nat,
  length : nat,
}

# A span of bytes where the start is given as an offset from the start of
# the previous span
type RelByteSpan = {
  offset : nat,
  length : nat,
}

# Predicate to check if one bytespan contains another. This includes
# if the two spans are equal
predicate ByteSpanContains :
  {
    byteSpan: ByteSpan,
    contains: ByteSpan
  }
  {S1, S2} where
    {Start1, Len1} = S1;
    {Start2, Len2} = S2;
    End1=Start1+Len1;
    End2=Start2+Len2;
    Start1<=Start2;
    End2<=End1

predicate RangeContains :
  {
    fileLines : Range,
    contains: Range
  }
  {S1, S2} where
    {F, LB1, CB1, LE1, CE1} = S1;
    {F, LB2, CB2, LE2, CE2} = S2;
    LB1 <= LB2;
    LE2 <= LE1;
    (LB1 < LB2 | CB1 <= CB2);
    (LE2 < LE1 | CE2 <= CE1)

# Multiple relative-offset bytespans
type ByteSpans = [RelByteSpan]

# Kind of language supported by Glean
type Language = enum {
  Buck | C | Cpp | Hack | Haskell  |
  ObjC | ObjCpp | Python | Thrift | Java | GraphQL
}

# Maps a file into the kind of language
predicate FileLanguage : {
  file : File,
  language : Language
}

type FileLocation = {
  file : File,
  span : ByteSpan,
}

# Why didn't Glean Indexer index a particular file?
type IndexFailureReason = enum {
  CompileError |
}

# It is a good practice to add all errors directly into db
# so it is easy to classify and investigate errors in future
predicate IndexFailure : {
  file : File,
  reason : IndexFailureReason,
  details : string,
}

}
